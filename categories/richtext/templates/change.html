<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Change Existing Formatting</title>
    <script src="{{ "js/range.js"|resource_path:"richtext" }}"></script>
    <script>
    
      var TESTS = {
          'backcolor' : {
            type: 'value',
            tests: [
              {html: '<FONT style="BACKGROUND-COLOR: #ffccaa">foo bar baz</FONT>', opt_arg: '#884422'},
              {html: '<span class="Apple-style-span" style="background-color: rgb(255, 0, 0);">foo bar baz</span>', opt_arg: '#0000ff'},
              {html: '<span style="background-color: #ff0000">foo bar baz</span>', opt_arg: '#0000ff'}
            ]
          },
          'fontname' : {
            type: 'value',
            tests: [
              {html: '<font face="Arial">foo bar baz</font>', opt_arg: 'Courier'},
              {html: '<span style="font-family:Arial">foo bar baz</span>', opt_arg: 'Courier'},
              {html: '<font face="Arial" style="font-family:Verdana">foo bar baz</font>', opt_arg: 'Courier'},
              {html: '<font face="Verdana"><font face="Arial">foo bar baz</font></font>', opt_arg: 'Courier'},
              {html: '<span style="font-family:Verdana"><font face="Arial">foo bar baz</font></span>', opt_arg: 'Courier'}
            ]
          },
          'fontsize' : {
            type: 'value',
            tests: [
              {html: '<font size=4>foo bar baz</font>', opt_arg: 1},
              {html: '<span class="Apple-style-span" style="font-size: large;">foo bar baz</span>', opt_arg: 1},
              {html: '<font size=1 style="font-size:x-small;">foo bar baz</font>', opt_arg: 5}
            ]
          },
          'forecolor' : {
            type: 'value',
            tests: [
              {html: '<font color="#ff0000">foo bar baz</font>', opt_arg: '#00ff00'},
              {html: '<span style="color:#ff0000">foo bar baz</span>', opt_arg: '#00ff00'},
              {html: '<font color="#0000ff" style="color:#ff0000">foo bar baz</span>', opt_arg: '#00ff00'}
            ]
          },
          'hilitecolor' : {
            type: 'value',
            tests: [
              {html: '<FONT style="BACKGROUND-COLOR: #ffccaa">foo bar baz</FONT>', opt_arg: '#884422'},
              {html: '<span class="Apple-style-span" style="background-color: rgb(255, 0, 0);">foo bar baz</span>', opt_arg: '#00ff00'},
              {html: '<span style="background-color: #ff0000">foo bar baz</span>', opt_arg: '#00ff00'}
            ]
          }
        };
      /** The document of the editable iframe */
      var editorDoc = null;
      /** Dummy text to apply and unapply formatting to */
      var TEST_CONTENT = 'foo bar baz';
      /** Constant for indicating an action is unsupported (threw exception) */
      var UNSUPPORTED = 'UNSUPPORTED';
      /** Total number of tests run */
      var numRun = 0;
      /** Total number of passing tests */
      var numPassing = 0;
      /** Whether tests were specified on the url parameter */
      var testsInUrl = false;

      /**
       * Color class allows cross-browser comparison of values, in several
       * formats:
       *   0xff00ff
       *   rgb(255, 0, 0)
       *   Number containing the hex value
       */
      function Color(value) {
        this.compare = function(other) {
          if (!this.valid || !other.valid) {
            return false;
          }
          return this.red == other.red && this.green == other.green && this.blue == other.blue;
        }
        this.parse = function(value) {
          var hexMatch = String(value).match(/#([0-9a-f]{6})/i);
          if (hexMatch) {
            this.red = parseInt(hexMatch[1].substring(0, 2), 16);
            this.green = parseInt(hexMatch[1].substring(2, 4), 16);
            this.blue = parseInt(hexMatch[1].substring(4, 6), 16);
            return true;
          }
          var rgbMatch = String(value).match(/rgb\(([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3})\)/i);
          if (rgbMatch) {
            this.red = Number(rgbMatch[1]);
            this.green = Number(rgbMatch[2]);
            this.blue = Number(rgbMatch[3]);
            return true;
          }
          if (Number(value)) {
            this.red = value & 0xFF;
            this.green = (value & 0xFF00) >> 8;
            this.blue = (value & 0xFF0000) >> 16;
            return true;
          }
          return false;
        }
        this.toString = function() {
          return this.red + ',' + this.green + ',' + this.blue;
        }
        this.valid = this.parse(value);
      }
      
      /**
       * Utility class for converting font size attribute to named styles
       * (e.g.) 1 -> 'x-small'
       */
       function Size(value) {
         this.parse = function(value) {
           if (Number(value)) {
             this.size = Number(value);
             return;
           }
           switch (value) {
             case 'x-small':
               this.size = 1;
               break;
             case 'small':
               this.size = 2;
               break;
             case 'medium':
               this.size = 3;
               break;
             case 'large':
               this.size = 4;
               break;
             case 'x-large':
               this.size = 5;
               break;
             case 'xx-large':
               this.size = 6;
               break;
             case 'xxx-large':
             case '-webkit-xxx-large':
               this.size = 7;
               break;
             default:
               this.size = null;
           }
         }
         this.compare = function(other) {
           return this.size && other.size && (this.size == other.size);
         }
         this.parse(value);
       }
    
      function getTestsToRun() {
        // The url param tests is a comma-separated list of the tests to run.
        // If not specified, run all tests.
        var queryString = document.location.search.replace(/^\?/, '');
        var queryParts = queryString.split('&');
        for (var i = 0; i < queryParts.length; i++) {
          var parts = queryParts[i].split('=');
          var name = parts[0].toLowerCase();
          if (name == 'tests' && parts.length > 1) {
            testsInUrl = true;
            return parts[1].split(',');
          }
        }
        // No tests in url parameter.
        var tests = [];
        for (var key in TESTS) {
          tests.push(key);
        }
        tests.sort();
        return tests;
      }

      function findTextNode(word, node) {
        if (node.nodeType == 3) {
          // Text node, check value.
          if (node.data.indexOf(word) != -1) {
            return node;
          }
        } else if (node.nodeType == 1) {
          // Element node, check children.
          for (var i = 0; i < node.childNodes.length; i++) {
            var result = findTextNode(word, node.childNodes[i]);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }

      /**
       * Selects the given word. Assumes the editor iframe contains a single text node.
       */
      function selectWord(word) {
        var textNode = findTextNode(word, editorDoc.body);
        if (!textNode) {
          return;
        }
        var start = textNode.data.indexOf(word);
        var range = createFromNodes(textNode, start, textNode, start + word.length);
        range.select();
      }
      
      function runCommand(command, index) {
        editorDoc.body.innerHTML = TESTS[command].tests[index].html;
        selectWord(TEST_CONTENT);
        try {
          editorDoc.execCommand(command, false, TESTS[command].tests[index].opt_arg);
        } catch (ex) {
          return UNSUPPORTED;
        }
      }
      
      function checkFontnameSuccess(index) {
        var textNode = findTextNode(TEST_CONTENT, editorDoc.body);
        if (!textNode) {
          // The text has been removed from the document, or split up for no reason.
          return false;
        }
        var expectedFont = TESTS['fontname'].tests[index].opt_arg;
        var foundExpected = false;
        
        // Loop through all the parent nodes that format the text node,
        // checking that there is exactly one font face attribute or
        // font family style, and that it's set correctly.
        var currentNode = textNode.parentNode;
        while(currentNode && currentNode.nodeName != 'BODY') {
          // Check font face attribute.
          if (currentNode.nodeName == 'FONT' && currentNode.getAttribute('face')) {
            if (currentNode.getAttribute('face') == expectedFont) {
              if (foundExpected) {
                // This is the correct font face, but the style has been
                // applied twice. This makes it hard for other browsers to
                // remove the style.
                return false;
              }
              foundExpected = true;
            } else {
              // This node has the wrong font face attribute.
              return false;
            }
          }
          // Check font family style.
          if (currentNode.style.fontFamily) {
            if (currentNode.style.fontFamily == expectedFont) {
              if (foundExpected) {
                // This is the correct font family, but the style has been
                // applied twice. This makes it hard for other browsers to
                // remove the style.
                return false;
              }
              foundExpected = true;
            } else {
              // This node has the wrong font family style.
              return false;
            }
          }
          currentNode = currentNode.parentNode;
        }
        return foundExpected;
      }
      
      function checkFontsizeSuccess(index) {
        var textNode = findTextNode(TEST_CONTENT, editorDoc.body);
        if (!textNode) {
          // The text has been removed from the document, or split up for no reason.
          return false;
        }
        var expectedSize = new Size(TESTS['fontsize'].tests[index].opt_arg);
        var foundExpected = false;
        
        // Loop through all the parent nodes that format the text node,
        // checking that there is exactly one font size attribute or
        // font size style, and that it's set correctly.
        var currentNode = textNode.parentNode;
        while(currentNode && currentNode.nodeName != 'BODY') {
          // Check font size attribute.
          if (currentNode.nodeName == 'FONT' && currentNode.getAttribute('size')) {
            if (new Size(currentNode.getAttribute('size')).compare(expectedSize)) {
              if (foundExpected) {
                // This is the correct font size, but the style has been
                // applied twice. This makes it hard for other browsers to
                // remove the style.
                return false;
              }
              foundExpected = true;
            } else {
              // This node has the wrong font size attribute.
              return false;
            }
          }
          // Check font size style.
          if (currentNode.style.fontSize) {
            if (new Size(currentNode.style.fontSize).compare(expectedSize)) {
              if (foundExpected) {
                // This is the correct font size, but the style has been
                // applied twice. This makes it hard for other browsers to
                // remove the style.
                return false;
              }
              foundExpected = true;
            } else {
              // This node has the wrong font size style.
              return false;
            }
          }
          currentNode = currentNode.parentNode;
        }
        return foundExpected;
      }
      
      function checkColorSuccess(command, index, attributeName, styleName) {
        var textNode = findTextNode(TEST_CONTENT, editorDoc.body);
        if (!textNode) {
          // The text has been removed from the document, or split up for no reason.
          return false;
        }
        var expectedColor = new Color(TESTS[command].tests[index].opt_arg);
        var foundExpected = false;
        
        // Loop through all the parent nodes that format the text node,
        // checking that there is exactly one font color attribute or
        // color style, and that it's set correctly.
        var currentNode = textNode.parentNode;
        while(currentNode && currentNode.nodeName != 'BODY') {
          // Check font attribute.
          if (attributeName && currentNode.nodeName == 'FONT' && currentNode.getAttribute(attributeName)) {
            if (new Color(currentNode.getAttribute(attributeName)).compare(expectedColor)) {
              if (foundExpected) {
                // This is the correct font attribute, but the style has been
                // applied twice. This makes it hard for other browsers to
                // remove the style.
                return false;
              }
              foundExpected = true;
            } else {
              // This node has the wrong font attribute.
              return false;
            }
          }
          // Check node style.
          if (currentNode.style[styleName]) {
            if (new Color(currentNode.style[styleName]).compare(expectedColor)) {
              if (foundExpected) {
                // This is the correct style, but the style has been
                // applied twice. This makes it hard for other browsers to
                // remove the style.
                return false;
              }
              foundExpected = true;
            } else {
              // This node has the wrong color style.
              return false;
            }
          }
          currentNode = currentNode.parentNode;
        }
        return foundExpected;
      }
      
      function checkSuccess(command, index) {
        switch(command) {
          case 'backcolor':
            return checkColorSuccess(command, index, null, 'backgroundColor');
            break;
          case 'fontname':
            return checkFontnameSuccess(index);
            break;
          case 'fontsize':
            return checkFontsizeSuccess(index);
            break;
          case 'forecolor':
            return checkColorSuccess(command, index, 'color', 'color');
            break;
          case 'hilitecolor':
            return checkColorSuccess(command, index, null, 'backgroundColor');
            break;
        }
        return null;
      }
      
      function outputResult(command, index) {        
        // Each command is displayed as a table row with 4 columns
        var tr = document.createElement('TR');
        var success = checkSuccess(command, index);
        if (success) {
          numPassing++;
        }
        numRun++;
        tr.className = success ? 'success' : 'fail';
        
        // Column 1: command name
        var td = document.createElement('TD');
        td.innerHTML = command;
        tr.appendChild(td);
        
        // Column 2: status
        td = document.createElement('TD');
        td.innerHTML = (success == null) ? '?' : (success == true ? 'PASS' : 'FAIL');
        tr.appendChild(td);
        
        // Column 3: opt_arg
        td = document.createElement('TD');
        td.innerHTML = TESTS[command].tests[index].opt_arg;
        tr.appendChild(td);
        
        // Column 4: original html
        td = document.createElement('TD');
        td.innerHTML = TESTS[command].tests[index].html.replace(/\</g, '&lt;').replace(/\>/g, '&gt;');;
        tr.appendChild(td);
        
        // Column 5: resulting html
        td = document.createElement('TD');
        td.innerHTML = editorDoc.body.innerHTML.replace(/\</g, '&lt;').replace(/\>/g, '&gt;');;
        tr.appendChild(td);
        
        var table = document.getElementById('output');
        table.appendChild(tr);
      }
      
      function runTests() {
        editorDoc = document.getElementById('editor').contentWindow.document;
        // Always set styleWithCSS to false, since it's not supported by IE.
        try {
          editorDoc.execCommand('styleWithCSS', false, false);
        } catch (ex) {
          // Not supported by IE.
        }
        var commands = getTestsToRun();
        for (var i = 0; i < commands.length; i++) {
          for (var j = 0; j < TESTS[commands[i]].tests.length; j++) {
            runCommand(commands[i], j);
            outputResult(commands[i], j);
          }
        }
        // Only report score if all tests were run (not a subset in the url parameter)
        if (!testsInUrl) {
          // Report score as a percentage of passing tests (0-100)
          var score = Math.round((numPassing / numRun) * 100);
          var url = '/beacon?category=richtext&csrf_token={{ csrf_token }}&results=change=' + score;
          new Image().src = url;
        }
      }
    </script>
    <style>
      .success {
        background-color: #93c47d;
      }
      .fail {
        background-color: #ea9999;
      }
    </style>
</head>
<body onload="runTests()">
  <table><tbody id="output"><tr><th>Command</th><th>Status</th><th>Argument</th><th>Original HTML</th><th>Resulting HTML</th></tr></tbody></table>
  <iframe name="editor" id="editor" src="editable.html"></iframe>
</body>
</html>
