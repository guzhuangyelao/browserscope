<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Query Command State and Value tests</title>
    <script src="{{ "js/range.js"|resource_path:"richtext" }}"></script>
    <script>
      var TESTS = {
          'backcolor' : {
            type: 'value',
            tests: [
              {html: '<FONT style="BACKGROUND-COLOR: #ffccaa">foo bar baz</FONT>', expected: new Color('#ffccaa')},
              {html: '<span class="Apple-style-span" style="background-color: rgb(255, 0, 0);">foo bar baz</span>', expected: new Color('#ff0000')},
              {html: '<span style="background-color: #ff0000">foo bar baz</span>', expected: new Color('#ff0000')}
            ]
          },
          'bold' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<b>foo bar baz</b>', expected: true},
              {html: '<STRONG>foo bar baz</STRONG>', expected: true},
              {html: '<span style="font-weight:bold">foo bar baz</span>', expected: true},
              {html: '<b style="font-weight:normal">foo bar baz</b>', expected: false},
              {html: '<b><span style="font-weight:normal;">foo bar baz</span>', expected: false}
            ]
          },
          'fontname' : {
            type: 'value',
            tests: [
              {html: '<font face="Arial">foo bar baz</font>', expected: 'Arial'},
              {html: '<span style="font-family:Arial">foo bar baz</span>', expected: 'Arial'},
              {html: '<font face="Arial" style="font-family:Courier">foo bar baz</font>', expected: 'Courier'},
              {html: '<font face="Courier"><font face="Arial">foo bar baz</font></font>', expected: 'Arial'},
              {html: '<span style="font-family:Courier"><font face="Arial">foo bar baz</font></span>', expected: 'Arial'}
            ]
          },
          'fontsize' : {
            type: 'value',
            tests: [
              {html: '<font size=4>foo bar baz</font>', expected: new Size(4)},
              // IE adds +1 to font size from font-size style attributes.
              // This is hard to correct for since it does NOT add +1 to size attribute from font tag.
              {html: '<span class="Apple-style-span" style="font-size: large;">foo bar baz</span>', expected: new Size(4)},
              {html: '<font size=1 style="font-size:x-large;">foo bar baz</font>', expected: new Size(5)}
            ]
          },
          'forecolor' : {
            type: 'value',
            tests: [
              {html: '<font color="#ff0000">foo bar baz</font>', expected: new Color('#ff0000')},
              {html: '<span style="color:#ff0000">foo bar baz</span>', expected: new Color('#ff0000')},
              {html: '<font color="#0000ff" style="color:#ff0000">foo bar baz</span>', expected: new Color('#ff0000')}
            ]
          },
          'hilitecolor' : {
            type: 'value',
            tests: [
              {html: '<FONT style="BACKGROUND-COLOR: #ffccaa">foo bar baz</FONT>', expected: new Color('#ffccaa')},
              {html: '<span class="Apple-style-span" style="background-color: rgb(255, 0, 0);">foo bar baz</span>', expected: new Color('#ff0000')},
              {html: '<span style="background-color: #ff0000">foo bar baz</span>', expected: new Color('#ff0000')}
            ]
          },
          'insertorderedlist' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<ol><li>foo bar baz</li></ol>', expected: true},
              {html: '<ul><li>foo bar baz</li></ul>', expected: false}
            ]
          },
          'insertunorderedlist' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<ol><li>foo bar baz</li></ol>', expected: false},
              {html: '<ul><li>foo bar baz</li></ul>', expected: true}
            ]
          },
          'italic' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<i>foo bar baz</i>', expected: true},
              {html: '<EM>foo bar baz</EM>', expected: true},
              {html: '<span style="font-style:italic">foo bar baz</span>', expected: true},
              {html: '<i><span style="font-style:normal">foo bar baz</span></i>', expected: false}
            ]
          },
          'justifycenter' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<div align="center">foo bar baz</div>', expected: true},
              {html: '<p align="center">foo bar baz</p>', expected: true},
              {html: '<div style="text-align: center;">foo bar baz</div>', expected: true}
            ]
          },
          'justifyfull' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<div align="justify">foo bar baz</div>', expected: true},
              {html: '<p align="justify">foo bar baz</p>', expected: true},
              {html: '<div style="text-align: justify;">foo bar baz</div>', expected: true}
            ]
          },
          'justifyleft' : {
            type: 'state',
            tests: [
              {html: '<div align="left">foo bar baz</div>', expected: true},
              {html: '<p align="left">foo bar baz</p>', expected: true},
              {html: '<div style="text-align: left;">foo bar baz</div>', expected: true}
            ]
          },
          'justifyright' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<div align="right">foo bar baz</div>', expected: true},
              {html: '<p align="right">foo bar baz</p>', expected: true},
              {html: '<div style="text-align: right;">foo bar baz</div>', expected: true}
            ]
          },
          'strikethrough' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<strike>foo bar baz</strike>', expected: true},
              {html: '<strike style="text-decoration: none">foo bar baz</strike>', expected: false},
              {html: '<s>foo bar baz</s>', expected: true},
              {html: '<del>foo bar baz</del>', expected: true},
              {html: '<span style="text-decoration:line-through">foo bar baz</span>', expected: true}
            ]
          },
          'subscript' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<sub>foo bar baz</sub>', expected: true}
            ]
          },
          'superscript' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<sup>foo bar baz</sup>', expected: true}
            ]
          },
          'underline' : {
            type: 'state',
            tests: [
              {html: 'foo bar baz', expected: false},
              {html: '<u>foo bar baz</u>', expected: true},
              {html: '<a href="http://www.foo.com">foo bar baz</a>', expected: true},
              {html: '<span style="text-decoration:underline">foo bar baz</span>', expected: true},
              {html: '<u style="text-decoration:none">foo bar baz</u>', expected: false},
              {html: '<a style="text-decoration:none" href="http://www.foo.com">foo bar baz</a>', expected: false}
            ]
          }
        };
      
      /**
       * Color class allows cross-browser comparison of values, which can
       * be returned from queryCommandValue in several formats:
       *   0xff00ff
       *   rgb(255, 0, 0)
       *   Number containing the hex value
       */
      function Color(value) {
        this.compare = function(other) {
          if (!this.valid || !other.valid) {
            return false;
          }
          return this.red == other.red && this.green == other.green && this.blue == other.blue;
        }
        this.parse = function(value) {
          var hexMatch = String(value).match(/#([0-9a-f]{6})/i);
          if (hexMatch) {
            this.red = parseInt(hexMatch[1].substring(0, 2), 16);
            this.green = parseInt(hexMatch[1].substring(2, 4), 16);
            this.blue = parseInt(hexMatch[1].substring(4, 6), 16);
            return true;
          }
          var rgbMatch = String(value).match(/rgb\(([0-9]{1,3}),\s*([0-9]{1,3}),\s*([0-9]{1,3})\)/i);
          if (rgbMatch) {
            this.red = Number(rgbMatch[1]);
            this.green = Number(rgbMatch[2]);
            this.blue = Number(rgbMatch[3]);
            return true;
          }
          if (Number(value)) {
            this.red = value & 0xFF;
            this.green = (value & 0xFF00) >> 8;
            this.blue = (value & 0xFF0000) >> 16;
            return true;
          }
          return false;
        }
        this.toString = function() {
          return this.red + ',' + this.green + ',' + this.blue;
        }
        this.valid = this.parse(value);
      }
      
      /**
       * Utility class for converting font sizes to the size
       * attribute in a font tag. Currently only converts px because
       * only the sizes and px ever come from queryCommandValue.
       */
      function Size(value) {
        var pxMatch = String(value).match(/([0-9]+)px/);
        if (pxMatch) {
          var px = Number(pxMatch[1]);
          if (px <= 10) {
            this.size = 1;
          } else if (px <= 13) {
            this.size = 2;
          } else if (px <= 16) {
            this.size = 3;
          } else if (px <= 18) {
            this.size = 4;
          } else if (px <= 24) {
            this.size = 5;
          } else if (px <= 32) {
            this.size = 6;
          } else if (px <= 47) {
            this.size = 7;
          } else {
            this.size = NaN;
          }
        } else {
          this.size = Number(value);
        }
        this.compare = function(other) {
          return this.size == other.size;
        }
        this.toString = function() {
          return String(this.size);
        }
      }

      /** The document of the editable iframe */
      var editorDoc = null;
      /** Dummy text to apply and unapply formatting to */
      var TEST_CONTENT = 'foo bar baz';
      /**
       * Word in dummy text that should change. Formatting is applied to a
       * single word instead of the entire text node because sometimes a 
       * style might get applied to the body node instead of wrapped around
       * the text, and that's not what's being tested.
       */
      var TEST_WORD = 'bar';
      /** Constant for indicating an action is unsupported (threw exception) */
      var UNSUPPORTED = 'UNSUPPORTED';
      /** Total number of tests run */
      var numRunState = 0;
      var numRunValue = 0;
      /** Total number of passing tests */
      var numPassingState = 0;
      var numPassingValue = 0;
      /** Whether tests were specified on the url parameter */
      var testsInUrl = false;
    
      function getTestsToRun() {
        // The url param tests is a comma-separated list of the tests to run.
        // If not specified, run all tests.
        var queryString = document.location.search.replace(/^\?/, '');
        var queryParts = queryString.split('&');
        for (var i = 0; i < queryParts.length; i++) {
          var parts = queryParts[i].split('=');
          var name = parts[0].toLowerCase();
          if (name == 'tests' && parts.length > 1) {
            testsInUrl = true;
            return parts[1].split(',');
          }
        }
        // No tests in url parameter.
        var tests = [];
        for (var key in TESTS) {
          tests.push(key);
        }
        tests.sort();
        return tests;
      }

      function findTextNode(word, node) {
        if (node.nodeType == 3) {
          // Text node, check value.
          if (node.data.indexOf(word) != -1) {
            return node;
          }
        } else if (node.nodeType == 1) {
          // Element node, check children.
          for (var i = 0; i < node.childNodes.length; i++) {
            var result = findTextNode(word, node.childNodes[i]);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }

      /**
       * Selects the given word. Assumes the editor iframe contains a single text node.
       */
      function selectWord(word) {
        var textNode = findTextNode(word, editorDoc.body);
        if (!textNode) {
          return;
        }
        var start = textNode.data.indexOf(word);
        var range = createFromNodes(textNode, start, textNode, start + word.length);
        range.select();
      }
      
      function runCommand(command, index) {
        editorDoc.body.innerHTML = TESTS[command].tests[index].html;
        selectWord(TEST_WORD);
        // Dummy val that won't match any expected vals, including false.
        var result = UNSUPPORTED;
        if (TESTS[command].type == 'state') {
          try {
            result = editorDoc.queryCommandState(command);
          } catch (ex) {
            result = UNSUPPORTED;
          }
        } else {
          try {
            // A return value of false indicates the command is not supported.
            result = editorDoc.queryCommandValue(command) || UNSUPPORTED;
          } catch (ex) {
            result = UNSUPPORTED;
          }
        }
        return result;
      }
      
      function commandSucceeded(command, index, result) {
        var expected = TESTS[command].tests[index].expected;
        if (expected instanceof Color) {
          return expected.compare(new Color(result));
        } else if (expected instanceof Size) {
          return expected.compare(new Size(result));
        } else {
          return (result == expected);
        }
      }

      function outputResult(command, index, result) {
        // Create table row for results.
        var tr = document.createElement('TR');
        var success = commandSucceeded(command, index, result);
        if (success) {
          TESTS[command].type == 'state' ? numPassingState++ : numPassingValue++;
        }
        TESTS[command].type == 'state' ? numRunState++ : numRunValue++;
        tr.className = success ? 'success' : 'fail';
        
        // Column 1: command name
        var td = document.createElement('TD');
        td.innerHTML = command;
        tr.appendChild(td);
        
        // Column 2: pass/fail
        td = document.createElement('TD');
        td.innerHTML = success ? 'PASS' : 'FAIL';
        tr.appendChild(td);
        
        // Column 3: test HTML
        td = document.createElement('TD');
        var testHtml = TESTS[command].tests[index].html.replace(/</g, '&lt;').replace(/>/g, '&gt;');
        td.innerHTML = testHtml.substring(0, testHtml.indexOf(TEST_CONTENT));
        tr.appendChild(td);
        
        // Column 4: Expected result
        td = document.createElement('TD');
        td.innerHTML = TESTS[command].tests[index].expected;
        tr.appendChild(td);
        
        // Column 5: Actual result
        td = document.createElement('TD');
        td.innerHTML = result;
        tr.appendChild(td);
        
        // Append result to the state or value table, depending on what
        // type of command this is.
        var table = document.getElementById(
          TESTS[command].type == 'state' ? 'output_state' : 'output_value');
        table.appendChild(tr);
      }
      
      function runTests() {
        editorDoc = document.getElementById('editor').contentWindow.document;
        // Always set styleWithCSS to false, since it's not supported by IE.
        try {
          editorDoc.execCommand('styleWithCSS', false, false);
        } catch (ex) {
          // Not supported by IE.
        }
        var commands = getTestsToRun();
        for (var i = 0; i < commands.length; i++) {
          for (var j = 0; j < TESTS[commands[i]].tests.length; j++) {
            var result = runCommand(commands[i], j);
            outputResult(commands[i], j, result);
          }
        }
        // Only report score if all tests were run (not a subset in the url parameter)
        if (!testsInUrl) {
          // Report score as a percentage of passing tests (0-100)
          var scoreState = Math.round((numPassingState / numRunState) * 100);
          var scoreValue = Math.round((numPassingValue / numRunValue) * 100);
          var url = '/beacon?category=richtext&csrf_token={{ csrf_token }}&results=queryCommandState=' + scoreState + ',queryCommandValue=' + scoreValue;
          new Image().src = url;
        }
      }
    
    </script>
    <style>
      .success {
        background-color: #93c47d;
      }
      .fail {
        background-color: #ea9999;
      }
    </style>
</head>
<body onload="runTests()">
  <h1>queryCommandState</h1>
  <table><tbody id="output_state"><tr><th>Command</th><th>Status</th><th>HTML</th><th>Expected</th><th>Actual</th></tr></tbody></table>
  <h1>queryCommandValue</h1>
  <table><tbody id="output_value"><tr><th>Command</th><th>Status</th><th>HTML</th><th>Expected</th><th>Actual</th></tr></tbody></table>
  <iframe name="editor" id="editor" src="editable.html"></iframe>
</body>
</html>
