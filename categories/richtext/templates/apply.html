<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Apply formatting tests</title>
    <script src="{{ "js/range.js"|resource_path:"richtext" }}"></script>
    <script>
      var TESTS = {
          'backcolor' : {
            'opt_arg': '#FF0000'},
          'bold' : {
            'opt_arg': null},
          'createbookmark' : {
            'opt_arg': 'bookmark_name'},
          'createlink' : {
            'opt_arg': 'http://www.openweb.org'},
          'decreasefontsize' : {
            'opt_arg': null},
          'fontname' : {
            'opt_arg': 'Arial'},
          'fontsize' : {
            'opt_arg': 4},
          'forecolor' : {
            'opt_arg': '#FF0000'},
          'formatblock' : {
            'opt_arg': 'h1',
            'wholeline': true},
          'hiliteColor' : {
            'opt_arg': '#FF0000'},
          'indent' : {
            'opt_arg': null,
            'wholeline': true},
          'inserthorizontalrule' : {
            'opt_arg': null,
            'collapse': true},
          'inserthtml': {
            'opt_arg': '<br>',
            'collapse': true},
          'insertimage': {
            'opt_arg': 'http://www.google.com/intl/en_ALL/images/logo.gif',
            'collapse': true},
          'insertorderedlist' : {
            'opt_arg': null,
            'wholeline': true},
          'insertunorderedlist' : {
            'opt_arg': null,
            'wholeline': true},
          'insertparagraph' : {
            'opt_arg': null,
            'wholeline': true},
          'italic' : {
            'opt_arg': null},
          'justifycenter' : {
            'opt_arg': null,
            'wholeline': true},
          'justifyfull' : {
            'opt_arg': null,
            'wholeline': true},
          'justifyleft' : {
            'opt_arg': null,
            'wholeline': true},
          'justifyright' : {
            'opt_arg': null,
            'wholeline': true},
          'strikethrough' : {
            'opt_arg': null},
          'subscript' : {
            'opt_arg': null},
          'superscript' : {
            'opt_arg': null},
          'underline' : {
            'opt_arg': null}};
            
      /** The document of the editable iframe */
      var editorDoc = null;
      /** Dummy text to apply and unapply formatting to */
      var TEST_CONTENT = 'foo bar baz';
      /**
       * Word in dummy text that should change. Formatting is applied to a
       * single word instead of the entire text node because sometimes a 
       * style might get applied to the body node instead of wrapped around
       * the text, and that's not what's being tested.
       */
      var TEST_WORD = 'bar';
      /** Constant for indicating an action is unsupported (threw exception) */
      var UNSUPPORTED = 'UNSUPPORTED';
      /** Total number of passing tests */
      var numPassing = 0;
      /** Whether tests were specified on the url parameter */
      var testsInUrl = false;
    
      function getTestsToRun() {
        // The url param tests is a comma-separated list of the tests to run.
        // If not specified, run all tests.
        var queryString = document.location.search.replace(/^\?/, '');
        var queryParts = queryString.split('&');
        for (var i = 0; i < queryParts.length; i++) {
          var parts = queryParts[i].split('=');
          var name = parts[0].toLowerCase();
          if (name == 'tests' && parts.length > 1) {
            testsInUrl = true;
            return parts[1].split(',');
          }
        }
        // No tests in url parameter.
        var tests = [];
        for (var key in TESTS) {
          tests.push(key);
        }
        tests.sort();
        return tests;
      }

      function findTextNode(word, node) {
        if (node.nodeType == 3) {
          // Text node, check value.
          if (node.data.indexOf(word) != -1) {
            return node;
          }
        } else if (node.nodeType == 1) {
          // Element node, check children.
          for (var i = 0; i < node.childNodes.length; i++) {
            var result = findTextNode(word, node.childNodes[i]);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }
      
      /**
       * Sets the selection to be collapsed at the start of the word,
       * or the start of the editor if no word is passed in.
       */
       function selectStart(word) {
         var textNode = findTextNode(word || '', editorDoc.body);
         var startOffset = 0;
         if (word) {
           startOffset = textNode.data.indexOf(word);
         }
         var range = createCaret(textNode, startOffset);
         range.select();
       }

      /**
       * Selects the given word. Assumes the editor iframe contains a single text node.
       */
      function selectWord(word) {
        var textNode = findTextNode(word, editorDoc.body);
        if (!textNode) {
          return;
        }
        var start = textNode.data.indexOf(word);
        var range = createFromNodes(textNode, start, textNode, start + word.length);
        range.select();
      }
 
      /** 
       * Gets the HTML before the text, so that we know how the browser
       * applied a style
       */
      function getSurroundingTags(text) {
        var html = editorDoc.body.innerHTML;
        var tagStart = html.indexOf('<');
        var index = editorDoc.body.innerHTML.indexOf(text);
        if (tagStart == -1 || index == -1) {
          return '';
        }
        return editorDoc.body.innerHTML.substring(tagStart, index);
      }
      
      function runCommand(command) {
        editorDoc.body.innerHTML = TEST_CONTENT;
        if (TESTS[command].collapse) {
          selectStart(TEST_WORD);
        } else {
          selectWord(TEST_WORD);
        }
        try {
          editorDoc.execCommand(command, false, TESTS[command].opt_arg);
        } catch (ex) {
          return UNSUPPORTED;
        }
        return getSurroundingTags(TESTS[command].wholeline? TEST_CONTENT : TEST_WORD);
      }
      
      function outputResult(command, result) {
        // The apply command "succeeded" if HTML was generated.
        var success = (result != UNSUPPORTED) && result;
        if (success) {
          numPassing++;
        }
        
        // Each command is displayed as a table row with 3 columns
        var tr = document.createElement('TR');
        tr.className = success ? 'success' : 'fail';
        
        // Column 1: command name
        var td = document.createElement('TD');
        td.innerHTML = command;
        tr.appendChild(td);
        
        // Column 2: pass/fail
        td = document.createElement('TD');
        td.innerHTML = success ? 'PASS' : 'FAIL';
        tr.appendChild(td);
        
        // Column 3: generated HTML (for passing commands)
        td = document.createElement('TD');
        // Escape the HTML in the result for printing.
        result = result.replace(/\</g, '&lt;').replace(/\>/g, '&gt;');
        td.innerHTML = success ? result : '&nbsp;';
        tr.appendChild(td);
        var table = document.getElementById('output');
        table.appendChild(tr);
      }
      
      function runTests() {
        editorDoc = document.getElementById('editor').contentWindow.document;
        // Always set styleWithCSS to false, since it's not supported by IE.
        try {
          editorDoc.execCommand('styleWithCSS', false, false);
        } catch (ex) {
          // Not supported by IE.
        }
        var commands = getTestsToRun();
        for (var i = 0; i < commands.length; i++) {
          var result = runCommand(commands[i]);
          outputResult(commands[i], result);
        }
        // Only report score if all tests were run (not a subset in the url parameter)
        if (!testsInUrl) {
          // Report score as a percentage of passing tests (0-100)
          var score = Math.round((numPassing / commands.length) * 100);
          var url = '/beacon?category=richtext&csrf_token={{ csrf_token }}&results=apply=' + score;
          new Image().src = url;
        }
      }
      
    </script>
    <style>
      .success {
        background-color: #93c47d;
      }
      .fail {
        background-color: #ea9999;
      }
    </style>
</head>
<body onload="runTests()">
  <table><tbody id="output"><tr><th>Command</th><th>Status</th><th>Output</th></tr></tbody></table>
  <iframe name="editor" id="editor" src="editable.html"></iframe>
</body>
</html>
